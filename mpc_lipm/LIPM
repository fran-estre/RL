# Script actualizado con mapeo de joints IK para evitar IndexError

import cvxpy as cp
import numpy as np
import pybullet as p
import pybullet_data
import time
from dataclasses import dataclass

@dataclass
class LIPMParams:
    g: float = 9.81
    h_c: float = 0.48       
    dt: float = 0.02        
    horizon: int = 20       
    @property
    def omega(self):
        return np.sqrt(self.g / self.h_c)

@dataclass
class MPCWeights:
    Q: float = 10.0
    R: float = 1e-2

class LIPMMPC:
    def __init__(self, params: LIPMParams, weights: MPCWeights):
        self.dt = params.dt
        self.horizon = params.horizon
        self.omega = params.omega
        dt = self.dt
        self.A = np.array([[1, dt, 0.5*dt**2],
                           [0, 1,        dt],
                           [0, 0,         1]])
        self.B = np.array([[0.5*dt**2],
                           [dt],
                           [1]])
        self.Q = weights.Q
        self.R = weights.R
        self.u_max = 50.0

    def solve(self, x0, ref_traj, zc_min=None, zc_max=None):
        N = self.horizon
        omega2 = self.omega**2
        x_var = cp.Variable((3, N+1))
        u_var = cp.Variable((1, N))
        cost = 0
        constraints = [x_var[:,0] == x0]

        for k in range(N):
            constraints += [x_var[:,k+1] == self.A @ x_var[:,k] + self.B @ u_var[:,k]]
            if zc_min is not None:
                zc = x_var[0,k] + u_var[0,k]/omega2
                constraints += [zc >= zc_min, zc <= zc_max]
            constraints += [cp.abs(u_var[:,k]) <= self.u_max]
            cost += self.Q*cp.square(x_var[0,k] - ref_traj[k]) \
                  + self.R*cp.square(u_var[0,k])
        cost += self.Q*cp.square(x_var[0,N] - ref_traj[N])

        prob = cp.Problem(cp.Minimize(cost), constraints)
        prob.solve(solver=cp.OSQP, warm_start=True)
        if u_var.value is None:
            print("[MPC] Warning: solver failed.")
            return 0.0
        return float(u_var.value[0,0])

def bezier_swing(p0, p1, p2, t):
    return (1 - t)**2 * p0 + 2*(1 - t)*t * p1 + t**2 * p2

class FootPlanner:
        def __init__(self, foot_links, leg_joints, dt, step_length=0.05, swing_time=0.5):
            self.foot_links = foot_links
            self.leg_joints = leg_joints
            self.dt = dt
            self.swing_duration = int(swing_time / dt)
            self.bezier_height = 0.05
            self.phase = 0
            self.step_length = step_length
            # Guardamos posiciones relativas al torso en X/Y para cada pata
            self.relative_offsets = {}

        def step(self, robot_id):
            swing_idx = self.phase % len(self.foot_links)
            support_legs = [l for i, l in enumerate(self.foot_links) if i != swing_idx]
            link_id = self.foot_links[swing_idx]

            # Obtener posición actual del pie en swing
            start = np.array(p.getLinkState(robot_id, link_id)[0])
            base_pos, base_ori = p.getBasePositionAndOrientation(robot_id)

            # Calcular offset relativo si no está guardado aún
            if swing_idx not in self.relative_offsets:
                rel = start - np.array(base_pos)
                self.relative_offsets[swing_idx] = rel

            # Planificar nuevo destino hacia adelante, relativo a la base
            rel_offset = self.relative_offsets[swing_idx].copy()
            rel_offset[0] += self.step_length  # avanzar X
            end = np.array(base_pos) + rel_offset
            ctrl = (start + end)/2 + np.array([0, 0, self.bezier_height])

            for i in range(self.swing_duration):
                t = (i + 1)/self.swing_duration
                target = bezier_swing(start, ctrl, end, t).tolist()
                ik_sol = p.calculateInverseKinematics(robot_id, link_id, target)
                for jidx in self.leg_joints[swing_idx]:
                    angle = ik_sol[jidx]
                    p.setJointMotorControl2(robot_id, jidx,
                                            controlMode=p.POSITION_CONTROL,
                                            targetPosition=float(angle),
                                            force=50)
                p.stepSimulation()
                time.sleep(self.dt)

            self.phase += 1
            return support_legs

def main():
    p.connect(p.GUI)
    params = LIPMParams()
    weights = MPCWeights()
    p.setGravity(0,0,-params.g)
    p.setAdditionalSearchPath(pybullet_data.getDataPath())
    p.loadURDF("plane.urdf")
    robot = p.loadURDF("D:\\ITMO trabajos de la u\\tesis\\py\\testing\\pybullet_robots\\data\\laikago\\laikago_toes.urdf",basePosition=[0, 0, params.h_c],baseOrientation=[0, 0.5, 0.5, 0], useFixedBase=False)

    # Determinar joints controlables y mapeo IK
    num_j = p.getNumJoints(robot)
    controllable = []
    for j in range(num_j):
        info = p.getJointInfo(robot, j)
        if info[2] in [p.JOINT_REVOLUTE, p.JOINT_PRISMATIC]:
            controllable.append(j)
    
    # Configuración según URDF
    foot_links = [14, 15, 12, 13]  # toeFL, toeFR, toeRL, toeRR
    leg_joints = {
    0: [3, 4, 5],   # FL: hip_motor, upper_leg, lower_leg
    1: [0, 1, 2],   # FR
    2: [9,10,11],   # RL
    3: [6, 7, 8]    # RR
    }


    planner = FootPlanner(foot_links, leg_joints,params.dt, step_length=0.05, swing_time=1)
    mpc_x = LIPMMPC(params, weights)
    mpc_y = LIPMMPC(params, weights)

    state_x = np.zeros(3)
    state_y = np.zeros(3)
    # Nueva referencia: avanzar 0.2 m en X durante el horizonte
    ref_y  = np.linspace(0, 0.2, params.horizon + 1)
    ref_x  = np.zeros(params.horizon + 1)  # mantener eje Y centrado

    while True:
        support = planner.step(robot)
        valid = [l for l in support if 0 <= l < num_j]
        if not valid: valid = [-1]

        pos = []
        for l in valid:
            st = p.getLinkState(robot, l)
            if st: pos.append(st[0])
        if not pos:
            pos = [p.getBasePositionAndOrientation(robot)[0]]

        xs = [p[0] for p in pos]
        ys = [p[1] for p in pos]

        xmin, xmax = min(xs), max(xs)
        ymin, ymax = min(ys), max(ys)

        ux = mpc_x.solve(state_x, ref_x, zc_min=xmin, zc_max=xmax)
        uy = mpc_y.solve(state_y, ref_y, zc_min=ymin, zc_max=ymax)

        ddx = ux / params.omega**2
        ddy = uy / params.omega**2
        mass = p.getDynamicsInfo(robot, -1)[0]
        p.applyExternalForce(robot, -1, [mass*ddx, mass*ddy,0], [0,0,0], p.LINK_FRAME)

        state_x += params.dt * np.array([state_x[1], state_x[2], ddx])
        state_y += params.dt * np.array([state_y[1], state_y[2], ddy])

        # 1. Calcula fuerza que el VMC aplica
        ddx = ux / params.omega**2
        ddy = uy / params.omega**2
        mass = p.getDynamicsInfo(robot, -1)[0]
        fx, fy = mass * ddx, mass * ddy

        p.applyExternalForce(robot, -1, [fx, fy, 0], [0, 0, 0], p.LINK_FRAME)

        # 2. Imprime retroalimentación
        print(f"[MPC] u_x: {ux:.3f}, u_y: {uy:.3f}")
        print(f"[VMC] a_x: {ddx:.3f}, a_y: {ddy:.3f} | F: ({fx:.2f}, {fy:.2f})")
        print(f"[STATE X] x: {state_x[0]:.3f}, dx: {state_x[1]:.3f}, ddx: {state_x[2]:.3f}")
        print(f"[STATE Y] y: {state_y[0]:.3f}, dy: {state_y[1]:.3f}, ddy: {state_y[2]:.3f}")
        print("-" * 60)
        p.stepSimulation()
        time.sleep(params.dt)

if __name__ == "__main__":
    main()
